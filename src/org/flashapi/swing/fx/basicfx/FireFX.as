/*** FireFX by Grant Skinner. May 30, 2007* Visit www.gskinner.com/blog for documentation, updates and more free code.** You may distribute and modify this class freely, provided that you leave this header intact,* and add appropriate headers to indicate your changes. Credit is appreciated in applications* that use this code, but is not required.** Please contact info@gskinner.com for more information.*//** * 	SPAS 3.0 CHANGES: *  * 	- package: "com.gskinner.effects" becomes "org.flashapi.swing.fx.basicfx" *  - extands org.flashapi.swing.fx.FXBase instead of flash.display.Sprite * 	- implements org.flashapi.swing.fx.FX interface * 	- FireFX.startFire() method becomes IEffect.render() method * 	- all "Inspectable" component properties have been removed * 	- FireFX.target becomes FXBase.source parameter * 	- FXBase.target designs the container where the effect will be displayed * 	- FireFX.targetName() method removed * 	- FireFX.startFire() method removed from the constructor function * 	- addition of the drawFrame method to use it as a class rather than a component * 	- org.flashapi.swinf.event.EffectEvent class implementation */package org.flashapi.swing.fx.basicfx {		// -----------------------------------------------------------	// FireFX.as	// -----------------------------------------------------------	/**	* @author Grant Skinner	* @version May 30, 2007	* @see http://www.gskinner.com/blog	* /////////////////////////////////	* @version SPAS 3.0	* @author Pascal ECHEMANN	* @version 1.0.0, 20/09/2007 15:41	* @see http://www.flashapi.org/	*/		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.events.Event;	import flash.filters.BlurFilter;	import flash.filters.ColorMatrixFilter;	import flash.filters.DisplacementMapFilter;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.text.TextField;	import org.flashapi.swing.event.EffectEvent;	import org.flashapi.swing.fx.basicfx.firelib.FireFxDTO;	import org.flashapi.swing.fx.FX;	import org.flashapi.swing.fx.FXBase;		/**	 * 	@langversion ActionScript 3.0	 * 	@playerversion Flash Player 9	 */	public class FireFX extends FXBase implements FX {				private var _fadeRate:Number=0.4;		private var _distortionScale:Number=0.4;		private var _distortion:Number=0.5;		private var _flameHeight:Number=0.3;		private var _flameSpread:Number=0.3;		//private var _blueFlame:Boolean = false;		private var _smoke:Number = 0;				// private properties:		// display elements:		private var displayBmp:BitmapData;		private var scratchBmp:BitmapData;		private var perlinBmp:BitmapData;		private var textBmp:BitmapData;				// geom:		private var mtx:Matrix;		private var pnt:Point;		private var drawColorTransform:ColorTransform;				// filters:		private var fireCMF:ColorMatrixFilter;		private var dispMapF:DisplacementMapFilter;		private var blurF:BlurFilter;				// other:		private var endCount:Number;		private var bmpsValid:Boolean=false;		private var perlinValid:Boolean=false;		private var filtersValid:Boolean = false;				/**		 * 		 * 	@param	source		 * 	@param	target		 */		public function FireFX(source:DisplayObject, target:DisplayObjectContainer) {			super(source);			initObj(target);		}				// getter/setters:		public function set width(value:Number):void {			bmpsValid &&= (value == _width);			_width = value | 0;			drawFrame();		}				public function set height(value:Number):void {			bmpsValid &&= (value == _height);			_height = value | 0;			drawFrame();		}				/**         * Sets the rate that flames fade as they move up. 0 is slowest, 1 is fastest.         *         * @default 0.4		 */		public function set fadeRate(value:Number):void {			filtersValid &&= (value == _fadeRate);			_fadeRate = value;		}		public function get fadeRate():Number { return _fadeRate; }				/**         * Sets the scale of flame distortion. 0.1 is tiny and chaotic, 1 is large and smooth.         *         * @default 0.4		 */		public function set distortionScale(value:Number):void {			perlinValid &&= (value == _distortionScale);			_distortionScale = value;		}		public function get distortionScale():Number { return _distortionScale; }				/**         * Sets the amount of distortion. 0.1 is little, 1 is chaotic.         *         * @default 0.4		 */		public function set distortion(value:Number):void {			filtersValid &&= (value == _fadeRate);			_distortion = value;		}		public function get distortion():Number { return _distortion; }				/**         * Sets the how high the flame will burn. 0 is zero gravity, 1 is a bonfire.         *         * @default 0.3		 */		public function set flameHeight(value:Number):void {			perlinValid &&= (value == _flameHeight);			_flameHeight = value;		}		public function get flameHeight():Number { return _flameHeight; }				/**         * Sets the how much the fire will spread out around the target. 0 is no spread, 1 is a lot.         *         * @default 0.3		 */		public function set flameSpread(value:Number):void {			filtersValid &&= (value == _flameSpread);			_flameSpread = value;		}		public function get flameSpread():Number { return _flameSpread; }				/**         * Indicates whether it should use a blue or red flame.         *         * @default false		 */		/*public function set blueFlame(value:Boolean):void {			filtersValid &&= (value == _blueFlame);			_blueFlame = value;		}		public function get blueFlame():Boolean { return _blueFlame; }*/				/**         * Sets the amount of smoke. 0 little, 1 lots.         *         * @default 0		 */		public function set smoke(value:Number):void {			filtersValid &&= (value == _smoke);			_smoke = value;		}		public function get smoke():Number { return _smoke; }				private var _fireDTO:FireFxDTO = new FireFxDTO();		/**		 * 	Sets or gets the filters properties of the fire effect.		 */		public function set filterObject(value:FireFxDTO):void {			_fireDTO = value;			filtersValid = false;		}		public function get filterObject():FireFxDTO { return _fireDTO; }				public function render():void {			if (!_target.contains(uioSprite))_target.addChild(uioSprite);			drawFrame();			endCount = 0;			uioSprite.addEventListener(Event.ENTER_FRAME, doFire);		}				public function remove():void {			_target.removeChild(uioSprite);			uioSprite.removeEventListener(Event.ENTER_FRAME, doFire);			this.dispatchEvent(new EffectEvent(EffectEvent.REMOVE));		}				/**         * Defines the shape of the fire. The fire will burn upwards, so it should be near the bottom, and centered in the FireFX component.         *         * @default 		 */				/**         * Clears the fire.		 */		public function clear():void {			if (displayBmp) {				displayBmp.fillRect(displayBmp.rect,0);			}		}				/**         * Stops the fire effect after letting it burn down over 20 frames.		 */		public function stopFire():void {			// let the fire burn down for 20 frames:			if (endCount == 0) { endCount = 20; }		}				private function initObj(target:DisplayObjectContainer):void {			_target = target;			uioSprite.scaleX = uioSprite.scaleY = 1;			_width = _height = 100;			mtx = new Matrix();			pnt = new Point();		}				private function updateBitmaps():void {			if (displayBmp) {				displayBmp.dispose();				displayBmp = null;				scratchBmp.dispose();				scratchBmp = null;				perlinBmp.dispose();				perlinBmp = null;			}			if (textBmp) {				textBmp.dispose();				textBmp = null;			}			if (src is TextField) {				textBmp = new BitmapData(src.width, src.height, true);				textBmp.draw(src);			} 			displayBmp = new BitmapData(_width, _height, true, 0);			scratchBmp = displayBmp.clone();			perlinBmp = new BitmapData(_width*3, _height*3, false, 0);						while (uioSprite.numChildren) { uioSprite.removeChildAt(0); }			uioSprite.addChild(new Bitmap(displayBmp));						updatePerlin();			updateFilters();			bmpsValid = true;		}				private function updatePerlin():void {			perlinBmp.perlinNoise(30*_distortionScale,20*_distortionScale,1,-Math.random()*1000|0,false,true,1|2,false);			perlinBmp.colorTransform(perlinBmp.rect,new ColorTransform(1,  1-_flameHeight*0.5  ,1,1,0,0,0,0));			perlinValid = true;		}				private function updateFilters():void {			var f:FireFxDTO = _fireDTO;			fireCMF = new ColorMatrixFilter([	f.redR - f.redFadeMult * _fadeRate, f.redG, f.redB, f.redA, f.redO,												f.greenR, f.greenG - f.greenFadeMult * _fadeRate, f.greenB, f.greenA, f.greenO,												f.blueR, f.blueG, f.blueB - f.blueFadeMult * _fadeRate, f.blueA, f.blueO,												0, 0.1, 0, 1, -25 + _smoke * 24		]);			drawColorTransform = new ColorTransform(0, 0, 0, 1, f.redOffset, f.greenOffset, f.blueOffset, 0);			dispMapF = new DisplacementMapFilter(perlinBmp, pnt, 1, 2, 14 * _distortion, -30, "clamp");			blurF = new BlurFilter(32*_flameSpread,32*_flameSpread,1);			filtersValid = true;		}				private function doFire(e:Event):void {			if (src == null || _target == null) return;			if (!bmpsValid) { updateBitmaps(); }			if (!perlinValid) { updatePerlin(); }			if (!filtersValid) { updateFilters(); }			if (endCount == 0) {				var drawMtx:Matrix = src.transform.matrix;				drawMtx.tx = src.x-x;				drawMtx.ty = src.y-y;				scratchBmp.fillRect(scratchBmp.rect,0);				drawColorTransform.alphaOffset = -Math.random() * 200 | 0;				src is TextField ? scratchBmp.draw(textBmp,drawMtx,drawColorTransform,"add") : scratchBmp.draw(src,drawMtx,drawColorTransform,"add");				scratchBmp.applyFilter(scratchBmp,scratchBmp.rect,pnt,blurF);				displayBmp.draw(scratchBmp,mtx,null,"add");			}			dispMapF.mapPoint = new Point( -Math.random()*(perlinBmp.width-displayBmp.width)|0, -Math.random()*(perlinBmp.height-displayBmp.height)|0 );			displayBmp.applyFilter(displayBmp,displayBmp.rect,pnt,dispMapF);			displayBmp.applyFilter(displayBmp,displayBmp.rect,pnt,fireCMF);			if (endCount != 0 && --endCount == 0) uioSprite.removeEventListener(Event.ENTER_FRAME,doFire);		}				private function drawFrame():void {			with (uioSprite.graphics) {				clear();				lineStyle(1, 0xFF0000, 0);				drawRect(0, 0, _width, _height);				endFill();			}		}	}}